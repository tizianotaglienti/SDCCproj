\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{svg}
\svgpath{{./figure/}}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}


\begin{document}

\title{Distributed Systems and Cloud Computing \\ 
B3 Project: Election Distributed Algorithms}

\author{\IEEEauthorblockN{Tiziano Taglienti (0304926)}
\IEEEauthorblockA{\textit{Università degli studi di Roma "Tor vergata"}\\
tiziano.taglienti@alumni.uniroma2.eu}
}

\maketitle

\begin{abstract}
Gli algoritmi di elezione distribuita sono un'applicazione degli algoritmi di consenso distribuito, e hanno lo scopo di determinare un coordinatore in caso di crash del leader attuale.
Questi funzionano se metà dei nodi rimangono funzionanti.
In questo progetto vengono implementati l'algoritmo Bully e quello ring-based di Chang e Roberts.
\end{abstract}

\begin{IEEEkeywords}
Ring-based, Bully, TCP, Docker, AWS EC2, Ansible
\end{IEEEkeywords}


\section{Introduzione}
Lo scopo del progetto è realizzare in Python un'applicazione distribuita che implementi gli algoritmi di elezione distribuita appena citati.
Si utilizzano dei container \textbf{Docker} per creare una rete decentralizzata di nodi e si esegue l'applicazione su un'istanza \textbf{EC2 con AWS}.

Nelle sezioni seguenti vengono descritti i servizi utilizzati dagli algoritmi, l'implementazione di questi ultimi e vengono discussi i test usati per valutare il funzionamento degli algoritmi.


\section{Servizi}


\subsection{Register}\label{register}

Il servizio \textbf{register} è necessario per la memorizzazione di tutti i processi che costituiscono la rete, associando un identificatore univoco a ognuno di essi.

Il server si comporta come una listening socket sulla porta TCP numero 1234 (vedi \textit{config.json}, in grado di accettare connessioni.
La socket rimane aperta per un tempo \textit{SOCK\_TIMEOUT}, al termine del quale viene inviata a tutti i processi una lista dei nodi nella rete, ordinati per identificatore crescente.
L'attribuzione dell'identificatore univoco ai nodi avviene dopo la fase di registrazione (inizialmente ogni nodo ha identificatore pari a \textit{DEFAULT\_ID}.
In seguito si stabilisce un coordinatore, cioè il processo che ha l'identificatore più grande. Per farlo, la variabile \textit{coordid} prende il valore dell'identificatore dell'ultimo nodo della lista e con un messaggio di livello \textit{DEBUG} viene comunicato a tutti i processi.

Durante la registrazione un nodo genera due socket: una viene usata per comunicare con il nodo register e l'altra serve per la ricezione di pacchetti da altri processi.


\subsection{Heartbeat}

Il servizio di \textbf{heartbeat} ha come scopo principale quello di rilevare i crash e i fallimenti del coordinatore.

Finché c'è un'elezione in corso non si mandano messaggi di heartbeat; inoltre il coordinatore non invia messaggi di questo tipo.
I processi sfruttano questo servizio attraverso un thread che invia messaggi di heartbeat al coordinatore, attraverso una socket dedicata.
I messaggi di heartbeat vengono inviati periodicamente in base al valore di \textit{HEARTBEAT\_TIME} e, dopo aver inviato il messaggio, il thread aspetta per un tempo \textit{TOTAL\_DELAY}, dopo il quale si va in crash, per poi iniziare una nuova elezione.

Un coordinatore che non è fallito risponde ai messaggi di heartbeat con dei messaggi di acknowledgement.

\begin{figure}[htbp]
  \centering
  \includesvg[inkscapelatex=false, width = 245pt]{heartbeat.svg}
  \caption{Heartbeat service invoked by two nodes.}
\end{figure}


\subsection{Verbose}

Questo servizio consente di mostrare tutti i messaggi scambiati tra i processi, indicandone alcune informazioni, quali:
\begin{itemize}
	\item Timestamp del messaggio (in formato hh:mm:ss);
	\item Caratteristiche del nodo (indirizzo IP, numero di porta, identificatore);
	\item Mittente;
	\item Destinatario;
	\item Contenuto del messaggio.
\end{itemize}
Per offrire un'esecuzione \textbf{verbose} si specifica il flag \textit{-v} da linea di comando, e conseguentemente si inserisce un messaggio di livello \textit{DEBUG} sul logger.


\subsection{Delay}\label{delay}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To stress more the system, the \textbf{delay method} is introduced in \textit{SDCC/sdcc/node/src/helper.py}. It generates a period waited by the sender to forward the current packet. This may cause the receiver timeout to expire.
\begin{lstlisting}
def delay(flag: bool, ub: int):
    if flag:
        delay = randint(0, floor(ub*1.5))
        time.sleep(delay)
\end{lstlisting}
It is activated by default when tests are performed (see. \ref{sec:tests}), but is also configured by the command line through the \textit{-d} flag.

\section{Algorithm Implementation}

What follows does not describe how the algorithms work, but only how particular aspects are implemented (reference at \cite{coulouris2005distributed}).

The implementation consists of the abstract class \footnote{Defined in \textit{SDCC/sdcc/node/src/Algorithm.py}} and election distributed algorithms classes that extend the first one. 

\begin{figure}[htbp]
  \centering
  \includesvg[inkscapelatex=false, width = 245pt]{class.svg}
  \caption{Logic implementation of the classes.}
\end{figure}

Six types of messages can be exchanged between nodes:

\begin{lstlisting}
class Type(Enum):
    ELECTION = 0
    END = 1
    ANSWER = 2
    HEARTBEAT = 3
    REGISTER = 4
    ACK = 5
\end{lstlisting}
ANSWER type is used only by the \textbf{Bully algorithm}, whereas REGISTER is sent during register phase.

Both algorithms begin with run the listening thread after which they start an election. Only after completing these two phases, the heartbeat can start. 
\begin{lstlisting}
def __init__(self, ...):
        ...
        self.lock = Lock()
        
        thread = Thread(target=self.listening)
        thread.daemon = True
        thread.start()

        self.start_election()
        Algorithm.heartbeat(self)
\end{lstlisting}
Many data are accessed simultaneously from multiple threads, thus a \textbf{lock} is defined to manage shared resources.
\begin{lstlisting}
self.lock.acquire()
if self.participant or (self.coordinator in [self.id, DEFAULT_ID]):
    self.lock.release()
    continue
\end{lstlisting}\caption{Example of \textbf{lock} management in heartbeat method.}

\subsection{Chang and Roberts Algorithm}\label{ring}

The algorithm is suitable for a collection of processes arranged in a logical ring. Each process has a
communication channel to the next one in the ring. All messages
are sent clockwise around the ring. The ID's node is used to define the \textbf{ring network}: the next node is the one with the greatest ID then current and the lowest among others.

\begin{figure}[htbp]
  \centering
  \includesvg[inkscapelatex=false, width = 245pt]{ring_1.svg}
  \caption{Election started by node with \textit{id=23} in Ring topology.}
\end{figure}

When a leader crash occurs or the node's timer associated with a heartbeat message elapses, the leader is removed from the nodes list, therefore remaining nodes can not interact with it even if it is still active.  

\subsection{Bully Algorithm}

With different respect to the \textbf{Ring-based algorithm}, the \textbf{Bully algorithm} assumes that each process knows which processes have higher identifiers and that it can communicate with all such processes. That information is sent by the register node (as described in \ref{register}) 

\begin{figure}[htbp]
  \centering
  \includesvg[inkscapelatex=false, width = 245pt]{bully_1.svg}
  \caption{Election started by node with \textit{id=23} using \textbf{Bully algorithm}.}
\end{figure}

\subsubsection{Scenarios}

Unlike in the \ref{ring}, for the \textbf{Bully algorithm}, the current leader is not removed from the nodes list during leader crash or timeout scenarios.

The considered cases when the leader is executing are:  

\begin{enumerate}
    \item If the leader delays sending the ACK packet, other nodes start a new election that will produce the next coordinator also if the previous one is running\footnote{In the next election it will be elected again.}.
    \item If the leader is stopped\footnote{Using $Ctrl\ +\ z$ combination.} a new election will start. In the meanwhile all messages sent to the sleeping node are queued, so when it wakes up\footnote{Using \textit{fg} command.} will receive those messages and begin the leader again.
\end{enumerate}

\section{Tests}\label{sec:tests}

Per provare il funzionamento degli algoritmi implementati sono stati eseguiti tre tipi di test:

\begin{enumerate}
    \item \textit{test\_any}: descrive il fallimento di un processo qualsiasi (escluso il coordinatore);
    \item \textit{test\_coord}: descrive il fallimento del coordinatore;
    \item \textit{test\_both}: descrive il fallimento di un processo qualsiasi e del coordinatore.
\end{enumerate}

In tutti i test, per interrompere un processo in ascolto su una specifica porta TCP si utilizza il metodo \textit{nodekill} della classe \textit{Utils}.
In questo metodo si sfrutta la libreria \textit{psutil} per filtrare i processi e ordinarli, per poi successivamente inviare un segnale di terminazione del nodo che ascolta su una porta di cui si specifica il numero.
N.B. Per fare ciò, bisogna avere i permessi di utente root, quindi è necessario eseguire cmd come amministratore.

\begin{lstlisting}
def nodekill(self, port: int):
    for node in psutil.process_iter():
        for connections in node.connections(kind = 'inet'):
            if connections.laddr.port == port:
                try:
                    node.send_signal(signal.SIGTERM)
                except psutil.NoSuchProcess:
                    pass
\end{lstlisting}

Per quanto riguarda l'esecuzione dei test, questa avviene in maniera interattiva: l'utente può decidere quale tipo di test eseguire, quale algoritmo utilizzare e il numero di processi che vengono creati (partendo da un minimo di quattro).

%%%%%%%%%%%%%%%%%%%%%%R
\section{Deployment}

The network is deployed on an \textbf{AWS EC2} instance where every node runs on a \textbf{Docker} container. 
\href{https://docs.docker.com/compose/}{\textbf{Docker Compose}} is used to automate the container's creation\footnote{See \textit{SDCC/sdcc/docker-compose.yml},  \textit{SDCC/sdcc/node/Dockerfile} and \textit{SDCC/sdcc/register/Dockerfile}.}. 

By default, \textbf{Docker Compose} creates a network where containers can communicate with each other, so that is used. 

\begin{figure}[htbp]\label{fig:arch}
  \centering
  \includesvg[inkscapelatex=false, width = 245pt]{arch.svg}
  \caption{Deployment using \textbf{AWS EC2} instance and \textbf{Docker} containers.}
\end{figure}

To automate the deployment procedure \href{https://www.ansible.com/}{\textbf{Ansible}} is used to install \textbf{Docker} and to forward the code application on an \textbf{EC2} instance. See \ref{fig:aws}.

\section{How To Use}\label{how}

The application can be run in two different ways:

\begin{enumerate}
    \item Local execution without \textbf{Docker} containers
    \item Remote execution on \textbf{AWS EC2} instance using \textbf{Docker} containers \footnote{That execution requires an \textbf{AWS} account.}(as shown in \ref{fig:arch})
\end{enumerate}

The complete list of commands is available \href{https://github.com/matt-merman/SDCC#running}{here}.

\section{Running Examples}

\begin{figure}[htb]\label{fig:register}
\includegraphics[width=\linewidth]{figure/register_terminal.png}
\caption{Register phase from three generic nodes and register node.}
\end{figure}

\begin{figure}[htb]\label{fig:verbose}
\includegraphics[width=\linewidth]{figure/verbose.png}
\caption{Example of the message showed by register node.}
\end{figure}

\begin{figure}[htb]\label{fig:tests}
\includegraphics[width=\linewidth]{figure/tests.png}
\caption{User interface to tests execution}
\end{figure}

\begin{figure}[htb]\label{fig:aws}
\includegraphics[width=\linewidth]{figure/aws_demo.png}
\caption{\textbf{Docker}, \textbf{Docker Compose} and application code info on an \textbf{AWS EC2} instance.}
\end{figure}

\printbibliography

\end{document}